### 75. What is DAX, and why is it important in Power BI?  
**Answer:**  
DAX (Data Analysis Expressions) is a formula language used in Power BI for creating custom calculations and logic on data models. It enables users to perform aggregations, filter data contextually, and build measures and calculated columns for advanced analytics.

---

### 76. What are some essential DAX functions commonly used in Power BI?  
**Answer:**  
- `SUM()`, `AVERAGE()`, `COUNT()`, `MAX()`, `MIN()` – Basic aggregation functions  
- `CALCULATE()` – Modifies filter context for advanced calculations  
- `FILTER()` – Returns a filtered table  
- `RELATED()` – Pulls values from related tables  

---

### 77. How does row context differ from filter context in DAX?  
**Answer:**  
- **Row Context:** Exists when calculations iterate over each row (e.g., in calculated columns or iterators like `SUMX`)  
- **Filter Context:** Refers to the subset of data visible due to filters in visuals or explicitly applied in DAX  

---

### 78. What is the difference between implicit and explicit measures?  
**Answer:**  
- **Implicit Measures:** Automatically generated by dragging fields into visuals (e.g., auto-sum of sales)  
- **Explicit Measures:** Defined using DAX; reusable, customizable, and optimized for performance  

---

### 79. What is the difference between a calculated column and a measure?  
**Answer:**  
- **Calculated Column:** Computed at row level, stored in the model, static until refresh  
- **Measure:** Evaluated dynamically based on filter context, memory-efficient, used for aggregations  

---

### 80. How does the ALL() function impact filtering in DAX?  
**Answer:**  
`ALL()` removes filters from a column or table, allowing calculations over entire datasets. Commonly used in percentage of total scenarios and when overriding existing filters.

---

### 81. What is the difference between RELATED() and LOOKUPVALUE()?  
**Answer:**  
- `RELATED()` fetches values from a related table via an existing relationship  
- `LOOKUPVALUE()` performs a key-value lookup based on matching criteria, independent of model relationships  

---

### 82. What does the CALCULATETABLE() function do?  
**Answer:**  
`CALCULATETABLE()` returns a table expression modified by filters. It allows advanced filtering and shaping of datasets for modeling or visualization purposes.

---

### 83. Compare EARLIER() with VAR in DAX.  
**Answer:**  
- `EARLIER()` is used in calculated columns to reference values from earlier row context iterations  
- `VAR` defines intermediate variables to simplify complex logic and improve performance and readability  

---

### 84. How can you improve performance while writing complex DAX measures?  
**Answer:**  
- Use iterators like `SUMX` carefully  
- Favor measures over calculated columns  
- Avoid deeply nested `FILTER()` expressions  
- Use pre-aggregated or summarized tables where applicable  

---

### 85. How does the GENERATESERIES() function work in DAX?  
**Answer:**  
`GENERATESERIES(start, end, increment)` creates a table of sequential values. Useful for slicers or generating reference datasets like year ranges or score bands.

---

### 86. When should you use CONTAINS() vs. LOOKUPVALUE()?  
**Answer:**  
- `CONTAINS()` checks for the existence of a specific value in a table  
- `LOOKUPVALUE()` returns a matching value from a column based on given filters  

---

### 87. How do you calculate Year-over-Year (YoY) growth in DAX?  
**Answer:**  
You can use a DAX measure like:
```DAX
YoY Growth = DIVIDE([Current Year Sales] - [Previous Year Sales], [Previous Year Sales])
```
To fetch previous year values, use SAMEPERIODLASTYEAR()
```DAX
Previous Year Sales = CALCULATE([Total Sales], SAMEPERIODLASTYEAR(Date[Date]))
```

---

### 88. What is the difference between SUM() and SUMX()?  
**Answer:**  
- SUM() adds values from a single column.  
- SUMX() iterates over a table expression, performing row-by-row calculations before summing the results.  

---

### 89. How do you create a running total in DAX?  
**Answer:**  
Use a DAX measure like:  
```DAX
Running Total = 
CALCULATE(
    SUM(Sales[Amount]), 
    FILTER(
        ALL(Sales[Date]), 
        Sales[Date] <= MAX(Sales[Date])
    )
)
```

---

### 90. How can you optimize memory usage in Power BI datasets?  
**Answer:**  
- Reduce column cardinality (e.g., group dates or categories).  
- Use numeric keys instead of long text columns.  
- Pre-aggregate data where possible to minimize row-level granularity.

---

### 91. What’s the difference between DISTINCT() and VALUES() in DAX?  
**Answer:**  
- `DISTINCT()` returns unique values from a column.  
- `VALUES()` also returns unique values but respects the current filter context and may return a blank row for missing data.

---

### 92. How do you calculate a moving average in DAX?  
**Answer:**  
Example for a 3-month moving average:  
```DAX
3-Month MA = AVERAGEX(
    DATESINPERIOD('Date'[Date], MAX('Date'[Date]), -3, MONTH),
    [Sales]
)
```

---

### 93. What is the purpose of the CROSSJOIN() function in DAX?  
**Answer:**  
CROSSJOIN() returns a Cartesian product of two or more tables. Useful for generating all possible combinations, such as scenario planning.

---

### 94. What is the significance of context transition in DAX?  
**Answer:**  
Context transition occurs when row context is converted into filter context. It happens implicitly when using CALCULATE() or CALCULATETABLE()—enabling dynamic evaluation based on row-level values, especially in calculated columns or row iterators.

---

### 95. How does the HASONEVALUE() function work in DAX and when should you use it?  
**Answer:**  
HASONEVALUE() checks if a column has exactly one value in the current filter context. It's useful in conditional logic, especially in visuals or cards, to avoid aggregation errors or display specific values only when a single selection is made.

---

### 96. What are iterator functions in DAX and how do they differ from standard aggregation functions?  
**Answer:**  
Iterator functions (e.g., SUMX, AVERAGEX, COUNTX) evaluate an expression for each row in a table and then perform aggregation. Unlike regular functions like SUM(), they allow row-by-row logic and complex expressions.

---

### 97. How does the DIVIDE() function improve numerical stability in DAX?  
**Answer:**  
DIVIDE(numerator, denominator, alternateResult) safely performs division by checking for division-by-zero errors. It avoids runtime exceptions and returns a fallback value (e.g., 0 or blank), making calculations more robust.

---

### 98. Explain the role of the USERELATIONSHIP() function in DAX.  
**Answer:**  
USERELATIONSHIP() activates an inactive relationship between two tables temporarily within CALCULATE(). It's useful when multiple relationships exist between tables but only one can be active at a time in the model.

---

### 99. What does the ISINSCOPE() function do in DAX?  
**Answer:**  
ISINSCOPE() checks whether a column is currently being evaluated in a specific level of hierarchy. It’s helpful in dynamic calculations (e.g., for multi-level drilldowns in visuals) to conditionally change logic depending on user navigation.

---

### 100. How can you calculate a dynamic Rank in DAX?  
**Answer:**  
Use the RANKX() function to calculate ranking dynamically. Example:
```DAX
Sales Rank = RANKX(ALL('Product'[Category]), [Total Sales], , DESC, Dense)
```
- This ranks product categories based on total sales, regardless of visual filters.

---

### 101. What is the purpose of the REMOVEFILTERS() function in DAX?  
**Answer:**  
REMOVEFILTERS() clears filters from specific columns or tables, similar to ALL(), but more selective. It helps isolate measures from slicers or visuals while preserving other filters.

---

### 102. How do you handle many-to-many relationships using DAX?  
**Answer:**  
- Use bridge tables with a common key.  
- Apply DAX functions like `TREATAS()` to simulate relationships.  
- Use `SUMX`/`FILTER` with model-aware logic to traverse through indirect relationships.

---

### 103. How does TREATAS() work in DAX and when should you use it?  
**Answer:**  
TREATAS() applies the values of one table as if they were filters on another unrelated table. It enables cross-filtering even when there's no relationship in the model.  
Example use:
```DAX
TREATAS(VALUES('Table1'[Region]), 'Table2'[Region])
```

---




